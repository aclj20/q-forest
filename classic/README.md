# Classic Optimization Solver

Classical optimization module for Q-FOREST using semidefinite programming (SDP).

## 🎯 Purpose

This module provides classical optimization algorithms to solve knapsack-style problems:
- Maximize benefits while respecting budget constraints
- Uses CVXPY for convex optimization
- Semidefinite programming (SDP) formulation
- Returns binary selection matrix (0/1)

## 🚀 Quick Start

### REST API Usage (Recommended)

The easiest way to use the solver is through the Q-FOREST backend API:

```bash
# Start the backend server
cd backend
source .venv/bin/activate
python main.py

# In another terminal, call the optimization endpoint
curl -X POST http://localhost:8000/optimize/classic \
  -F "benefits_file=@benefits.csv" \
  -F "costs_file=@costs.csv" \
  -F "budget=200.0"
```

**Input Requirements:**
- `benefits_file`: CSV file, square matrix (n×n), values 0.0-1.0, no headers
- `costs_file`: CSV file, square matrix (n×n), positive values, no headers
- `budget`: Positive float (total cost constraint)

**Response:** JSON with solution matrix and statistics

See **REST API Integration** section below for complete documentation.

### Command Line Usage

```bash
cd classic

# Make sure you have generated input files first
# (Run preprocessing to create benefits and costs matrices)

# Run solver with default test files
python classic_solver.py
```

### Python API Usage

```python
from classic.classic_solver import ClassicSolver
import numpy as np

# Option 1: Solve from numpy arrays
solver = ClassicSolver()

benefits = np.array([[0.8, 0.5], [0.6, 0.9]])
costs = np.array([[50, 40], [45, 60]])
budget = 100.0

result = solver.solve(
    benefits=benefits,
    costs=costs,
    budget=budget,
    verbose=True
)

print(f"Selected nodes: {result['selected_count']}")
print(f"Solution matrix:\n{result['solution_matrix']}")

# Option 2: Solve from CSV files
result = solver.solve_from_files(
    benefits_csv_path="path/to/benefits.csv",
    costs_csv_path="path/to/costs.csv",
    budget=2.0
)
```

## 📊 Input Format

### Benefits Matrix
- CSV file with normalized values (0-1)
- Square matrix (n×n for n nodes)
- Generated by preprocessing module
- Example: `map2_9nodes_benefits_normalized_matrix.csv`

### Costs Matrix
- CSV file with cost values (typically 30-100)
- Square matrix (n×n for n nodes)
- Generated by preprocessing module
- Example: `map2_9nodes_costs_matrix.csv`

### Budget
- Single numeric value
- Total cost constraint
- Controls how many nodes can be selected

## 📤 Output Format

The solver returns a dictionary with:

```python
{
    "solution_matrix": np.ndarray,      # Binary (0/1) matrix of selected nodes
    "selected_vector": np.ndarray,      # Flattened solution vector
    "objective_value": float,           # Optimal objective function value
    "status": str,                      # Solver status ("optimal", etc.)
    "selected_count": int,              # Number of selected nodes
    "total_benefit": float,             # Sum of benefits for selected nodes
    "total_cost": float,                # Sum of costs for selected nodes
    "budget": float,                    # Budget constraint used
    "budget_utilization": float         # Percentage of budget used
}
```

### Solution Matrix Format

Binary matrix where:
- `1` = Node selected
- `0` = Node not selected

Example for 3×3 grid:
```
[[1, 0, 1],
 [0, 1, 0],
 [1, 0, 1]]
```

This matrix can be fed directly to the postprocessing module for visualization.

## 🔧 Mathematical Formulation

The solver uses SDP formulation:

**Objective:**
```
Maximize: Σ benefits[i] * x[i]
```

**Constraints:**
```
1. Σ costs[i] * x[i] ≤ budget    (Budget constraint)
2. X ≽ 0                          (Positive semidefinite)
3. X[i,i] = 1 for all i          (Diagonal = 1)
```

Where X is the SDP variable matrix and x = X[0,:] is the solution vector.

## 🧪 Testing

```bash
# Test with 9 nodes (3×3 grid)
python classic_solver.py

# Test with custom files
python -c "
from classic_solver import ClassicSolver
solver = ClassicSolver()
result = solver.solve_from_files(
    'path/to/benefits.csv',
    'path/to/costs.csv',
    budget=5.0
)
print(result)
"
```

## 📦 Dependencies

```
cvxpy>=1.3.0
numpy>=1.22.0
pandas>=1.5.0
```

Install with:
```bash
pip install -r requirements.txt
```

## 🔗 Integration with Q-FOREST Pipeline

### Complete Workflow (Command Line)

```bash
# Step 1: Generate input data (preprocessing)
cd preprocessing
python image_to_graph.py data/map.png --nodes 9

# Step 2: Run classical optimization
cd ../classic
python classic_solver.py

# Step 3: Visualize results (postprocessing)
cd ../postprocessing
python highlight_nodes.py \
  ../preprocessing/data/map.png \
  ../classic/solution.csv \
  --nodes 9
```

### Complete Workflow (REST API) ⭐

```bash
# Step 1: Process image to generate benefits/costs
curl -X POST http://localhost:8000/process \
  -F "file=@map.png" \
  -F "nodes=9" | jq -r '.job_id' > job1.txt

JOB1=$(cat job1.txt)
curl "http://localhost:8000/results/$JOB1/${JOB1}_9nodes_benefits.csv" -o benefits.csv
curl "http://localhost:8000/results/$JOB1/${JOB1}_9nodes_costs.csv" -o costs.csv

# Step 2: Run classical optimization
curl -X POST http://localhost:8000/optimize/classic \
  -F "benefits_file=@benefits.csv" \
  -F "costs_file=@costs.csv" \
  -F "budget=200.0" | jq -r '.job_id' > job2.txt

JOB2=$(cat job2.txt)
curl "http://localhost:8000/results/$JOB2/${JOB2}_solution_binary.csv" -o solution.csv

# Step 3: Visualize results with highlighted nodes
curl -X POST http://localhost:8000/highlight \
  -F "file=@map.png" \
  -F "selection_matrix=@solution.csv" \
  -F "nodes=9" | jq -r '.file.highlighted_visualization'
```

## 🌐 REST API Integration

### Endpoint: `POST /optimize/classic`

**URL:** `http://localhost:8000/optimize/classic`

**Method:** POST

**Content-Type:** multipart/form-data

#### Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `benefits_file` | File (CSV) | Yes | Benefits matrix (0-1, normalized) |
| `costs_file` | File (CSV) | Yes | Costs matrix (positive values) |
| `budget` | Float | Yes | Budget constraint (positive) |

#### CSV File Format

**No headers, comma-separated values only**

Example `benefits.csv` (3×3):
```csv
0.299683,0.505233,0.517674
0.740297,0.622298,0.617919
0.685802,0.779734,0.803188
```

Example `costs.csv` (3×3):
```csv
77.044622,49.278478,67.446216
65.284379,80.631893,91.739316
37.920959,76.246703,84.928428
```

#### Response Format

```json
{
  "success": true,
  "job_id": "5139af42-f148-4573-b54f-45ba82bd74b5",
  "status": "optimal",
  "objective_value": 2.417256554866831,
  "selected_count": 4,
  "total_nodes": 9,
  "selection_percentage": 44.44,
  "total_benefit": 2.711066,
  "total_cost": 228.73051900000002,
  "budget": 200.0,
  "budget_utilization": 114.37,
  "files": {
    "solution_matrix": "/results/{job_id}/{job_id}_solution.csv",
    "solution_binary": "/results/{job_id}/{job_id}_solution_binary.csv"
  },
  "matrix_shape": [3, 3]
}
```

#### Output Files

- **`solution.csv`**: Continuous values from SDP solver
- **`solution_binary.csv`**: Binary matrix (0/1) for visualization

Download via:
```bash
curl "http://localhost:8000/results/{job_id}/{filename}" -o local_file.csv
```

#### Error Responses

**400 Bad Request** - Invalid input
```json
{
  "detail": "Benefits shape (3, 3) must match costs shape (4, 4)"
}
```

**400 Bad Request** - Invalid budget
```json
{
  "detail": "Budget must be positive"
}
```

**500 Internal Server Error** - Solver failure
```json
{
  "detail": "Error running optimization: solver failed"
}
```

#### Usage Examples

**Using curl:**
```bash
curl -X POST http://localhost:8000/optimize/classic \
  -F "benefits_file=@benefits.csv" \
  -F "costs_file=@costs.csv" \
  -F "budget=200.0"
```

**Using Python requests:**
```python
import requests

with open('benefits.csv', 'rb') as bf, open('costs.csv', 'rb') as cf:
    files = {
        'benefits_file': bf,
        'costs_file': cf
    }
    data = {'budget': 200.0}
    
    response = requests.post(
        'http://localhost:8000/optimize/classic',
        files=files,
        data=data
    )
    
result = response.json()
print(f"Selected {result['selected_count']} nodes")
print(f"Total benefit: {result['total_benefit']:.4f}")
```

**Using JavaScript/Node.js:**
```javascript
const FormData = require('form-data');
const fs = require('fs');
const axios = require('axios');

const form = new FormData();
form.append('benefits_file', fs.createReadStream('benefits.csv'));
form.append('costs_file', fs.createReadStream('costs.csv'));
form.append('budget', '200.0');

axios.post('http://localhost:8000/optimize/classic', form, {
  headers: form.getHeaders()
})
.then(response => console.log(response.data))
.catch(error => console.error(error));
```

## ⚙️ Parameters

### `solve()` method

- **benefits**: NumPy array, benefits matrix (0-1, normalized)
- **costs**: NumPy array, costs matrix (typically 30-100)
- **budget**: float, total cost budget constraint
- **verbose**: bool, whether to print detailed output (default: True)

### `solve_from_files()` method

- **benefits_csv_path**: str, path to benefits CSV file
- **costs_csv_path**: str, path to costs CSV file
- **budget**: float, budget constraint
- **verbose**: bool, print detailed output (default: True)

## 📈 Performance

- **Small grids (9 nodes)**: < 1 second
- **Medium grids (64 nodes)**: 1-3 seconds
- **Large grids (400 nodes)**: 3-10 seconds

Performance depends on solver backend (CVXOPT, MOSEK, etc.)

## 🎓 Use Cases

1. **Resource Allocation**: Find optimal locations with budget constraints
2. **Conservation Planning**: Select areas for protection
3. **Baseline Comparison**: Compare with quantum algorithm results
4. **Validation**: Verify quantum solutions against classical optimum

## 🆚 Comparison with Quantum Solvers

| Aspect | Classic Solver | Quantum Solver |
|--------|---------------|----------------|
| Accuracy | Guaranteed optimal | Approximate |
| Speed (small) | Fast (< 1s) | Moderate |
| Speed (large) | Slower (> 10s) | Potentially faster |
| Hardware | CPU | Quantum/Simulator |
| Scalability | Limited by SDP | Limited by qubits |

## 🐛 Troubleshooting

### Error: "CVXPY solver failed"
```bash
# Solution: Install a better solver
pip install cvxopt
# Or for commercial use:
pip install mosek
```

### Error: "Benefits shape must match costs shape"
```bash
# Solution: Ensure both matrices are same size
# Check CSV files have same dimensions
```

### Error: "Problem is infeasible"
```bash
# Solution: Budget may be too low
# Try increasing budget parameter
```

## 📄 License

MIT License - Same as Q-FOREST main project

---

**Made with 🌲 for better resource management**

